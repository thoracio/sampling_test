open Printf

type chessboard = {up_left_corner : float*float; width : float; height : float;
                   rows : int; columns : int}
(*the chessboard can generate the elements of a matrix defining a zone in the
 *plane, we keep as data:
 *the up left corner of the matrix, the width and height, and the number of
 *elements by row and column
 *)

let make_chessboard (u_l_c : float*float) (w : float) (h : float)
                    (r : int) (c : int) =
    {up_left_corner = u_l_c; width = w; height = h; rows = r; columns = c}
(*create a chessboard from the input data*)

let is_nan (x : float) = x<>x

let is_nan_tuple (x : float * float) = x<>x

let is_valid cb =
  let {up_left_corner = u_l_c; width = w; height = h;
  rows = r; columns = c} = cb in
  if r<=1 || c<=1 || w=0. || h=0. || (is_nan_tuple u_l_c) then false else true
(*test if the the chessboard cb is a valid chessboard*)

let up_left_corner cb =
  let {up_left_corner = u_l_c; width = w; height = h;
  rows = r; columns = c} =  cb in u_l_c

let rows cb =
  let {up_left_corner = u_l_c; width = w; height = h;
  rows = r; columns = c} = cb in r

let columns cb =
  let {up_left_corner = u_l_c; width = w; height = h;
  rows = r; columns = c} = cb in c

let width cb =
  let {up_left_corner = u_l_c; width = w; height = h;
  rows = r; columns = c} = cb in w

let height cb =
  let {up_left_corner = u_l_c; width = w; height = h;
  rows = r; columns = c} = cb in h

let w_step cb =
  if is_valid cb then
  (width cb) /. (float ((columns cb) - 1))
  else failwith "Chessboard: invalid chessboard."
(*the space between two adjacent elements in a column in the chessboard cb*)

let h_step cb =
  if is_valid cb then
  (height cb) /. (float ((rows cb) - 1))
  else failwith "Chessboard: invalid chessboard."
(*the space between two adjacent elements in a row in the chessboard cb*)

let nb_blocks cb =
  if is_valid cb then
  ((rows cb) - 1) * ((columns cb) - 1)
  else failwith "Chessboard: invalid chessboard."
(*returns the number of blocks in the chessboard cb*)
(*a block is four elements generated by the chessboard such that:
 *their form a rectangle in the plane
 *any of the four elements is adjacent to other two
 *)

let nb_points cb =
  if is_valid cb then
  (rows cb) * (columns cb)
  else failwith "Chessboard: invalid chessboard."
(*returns the number of points in the chessboard cb*)

let to_coor cb nb =
  let c = columns cb in
  if nb mod c = 0 then
    (nb / c), c
  else
    ((nb / c) + 1), (nb mod c)
(*transform the given number in his equivalent in (i,j) coordinates for the
 *given chessboard cb
 *)

let to_nb cb (i,j) =
  let c = columns cb in
  (c * (i-1)) + j
(*transform the given matrix index (i,j) in his number equivalent for the
 *chessboard cb
 *)

let pick_point cb nb =
  if is_valid cb then begin
  if nb > (nb_points cb) then failwith "Chessboard: index out of bonds."
  else
    let x0,y0 = up_left_corner cb in
    let c = columns cb in
    let w_s = w_step cb in
    let h_s = h_step cb in
    if nb mod c = 0 then
      (x0 +. w_s*.(float (c-1))),
      (y0 -. h_s*.(float (nb/c - 1)))
    else
      (x0 +. w_s*.(float ((nb mod c) -1))),
      (y0 -. h_s*.(float (nb/c)))
  end
  else failwith "Chessboard: invalid chessboard."
(*pick a point from the chessboard by his number identifiant*)

let pick_point_coor cb (i,j) =
  if is_valid cb then
    pick_point cb (to_nb cb (i,j))
  else failwith "Chessboard: invalid chessboard."
(*pcik a point from the chessboard by his coordinate identifiant*)

let pick_block cb nb =
  if is_valid cb then begin
    let c = columns cb in
    let r = rows cb in
    if nb > (c-1)*(r-1) then failwith "Chessboard: index out of bonds."
    else begin
    if nb mod (c-1) = 0 then
      let n = nb + ((nb / (c-1))-1) in
      (pick_point cb n), (pick_point cb (n+1)), (pick_point cb (n+c)),
      (pick_point cb (n+c+1))
    else
      let n = nb + (nb / (c-1)) in
      (pick_point cb n), (pick_point cb (n+1)), (pick_point cb (n+c)),
      (pick_point cb (n+c+1))
    end
  end
  else failwith "Chessboard: invalid chessboard."
(*pick a whole block from the chessboard by his number identifiant*)

let test_block bk f =
  let (a1,a2), (b1,b2), (c1,c2), (d1,d2) = bk in
  let a = f a1 a2 and b = f b1 b2 in
  let c = f c1 c2 and d = f d1 d2 in
  if a=0. || b=0. || c=0. || d=0. then 0
  else if (a*.b)>0. && (c*.d)>0. && (a*.c)>0. then 1
  else -1
(*test if the four vertices of the square have the same sign, that is, if the
 *function f has not sign change in the block, return -1 if the function
 *crosses the block, 1 if not and 0 if some of the vertices is a zero for f
 *)
let print_elem cb (i,j) =
  if i>(rows cb) || j>(columns cb) then failwith "Chessboard: index out
                                                  of bonds"
  else
  let x,y = pick_point_coor cb (i,j) in
  printf "(%f, %f)" x y

let print_block cb nb =
  if nb > (nb_blocks cb) then failwith "Chessboard: index out of bonds"
  else
  let bk = pick_block cb nb in
  let (a1,a2), (b1,b2), (c1,c2), (d1,d2) = bk in
  printf "(%f, %f) (%f, %f)\n(%f, %f) (%f, %f)" a1 a2 b1 b2 c1 c2 d1 d2

let print_chessboard_line cb l=
  let c = columns cb in
  for i=1 to (c-1) do
    print_elem cb (l,i);
    printf " ";
  done;
  print_elem cb (l,c)

let print_chessboard cb =
  let r = rows cb in
  for i=1 to r do
    print_chessboard_line cb i;
    printf "\n"
  done;


